        - #Author: João Lazzaro
        - #This codes solves the agent problem for the Krussell-Smith case
        - #
        - using Optim, Interpolations
        - include("CRRA_utility.jl")
        - #Uncomment the section below to test this code
        - 
        - 
        - function VFI_KS(A::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},
        -     E::Array{Float64,1},pdfE::Array{Float64,2},Z::Array{Float64,1},pdfZ::Array{Float64,2},
        -     K::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},
        -     H::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}} ,
        -     K1::Function,H1::Function,b::Array{Float64,2},d::Array{Float64,2},Vinitial::Function;
        -     α::Float64 = α,β::Float64 = β, η::Float64 = η, μ::Float64 =μ,
        -      tol = 1e-6, iterate::String = "Value",R::Function= R,w::Function= w,damp::Float64=2/3,verbose::Bool=false)
        -     #A: Individual Asset grid
        -     #E: Individual productivity grid
        -     #pdfE: pdf of E
        -     #Z: Aggregate shocks grid
        -     #pdfZ: pdf of Z
        -     #K: Aggregate capital grid
        -     #H: Aggregate labor grid
        -     #Vinitial: Guess for the Value function
        1     nA = length(A)
        -     nZ = length(Z)
        -     nE = length(E)
        -     nH = length(H)
        -     #Defining consumption function:
   933253     c(a::Float64,e::Float64, n::Float64 ,a1::Float64,k::Float64,h::Float64,z::Float64) =  R(k,h,z)*a+e*w(k,h,z)*n-a1
        - 
        -     #Constructing the stochastic pdf
        2     pdf = [πz*πe for πz in pdfZ, πe in pdfE] #nZxnZxnExnE
        1     pdf = permutedims(pdf, (1,3,2,4)) #nZxnExnZxnE
        - 
        -     #Guess for Value function
        1     V(a::Float64,e::Float64,k::Float64,h::Float64,z::Float64) = Vinitial(a,e,K,H,z) #u(c(a,e,0.0,a,k,h,z),1.0)
        - 
        -     #Expected value function given states and a value function V
        1     function EV(a::Float64,e::Float64,z::Float64,k::Float64;b::Array{Float64,2}=b,d::Array{Float64,2}=d,
        -         E::Array{Float64,1}=E,
        -         H::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}=H,
        -         K::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}=K,
        -         Z::Array{Float64,1}=Z,
        -         pdf::Array{Float64,4}=pdf, nE::Int64 = nE, nZ::Int64=nZ)
   939958         i = findfirst(E.==e)
        -         j = findfirst(Z.==z)
        - 
   626197         k1 = K1(k,Z[j];b=b)
   624079         h1 = H1(k,Z[j];d=d)
        -         expected = 0.0
   929192         for e1=1:nE, z1 = 1:nZ
  5458561             expected += pdf[j,i,z1,e1]*V(a,E[e1],k1,h1,Z[z1])
        -             #Tommorrow the value is the capital stock following the law of motion and the expected value for the shocks
        -         end
   311996         return expected
        -     end
        -     #Functions to be minimized by the solver
        -     #Choosing asset and labor
        1     function Vf(x::Array{Float64,1};β::Float64 = β, a::Int64= a,e::Int64=e,z::Int64=z,h::Int64=h,k::Int64=k,
        -         A::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}=A,
        -         E::Array{Float64,1}=E,
        -         K::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}=K,
        -         H::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}=H,Z::Array{Float64,1}=Z)
        -         return -(u(c(A[a],E[e],x[2],x[1],K[k],H[h],Z[z]),1-x[2]) + β * EV(x[1],E[e],Z[z],K[k]))
        -     end
        -     #choosing only asset (either we know the agent is unemployed or exogenous labor)
        1     function Vf(x::Float64;β::Float64 = β, a::Int64= a,e::Int64=e,z::Int64=z,h::Int64=h,k::Int64=k,
        -         A::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}=A,
        -         E::Array{Float64,1}=E,
        -         K::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}=K,
        -         H::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}=H,Z::Array{Float64,1}=Z)
   627078         if E[e]<=0
   312335             return -(u(c(A[a],E[e],0.0,x,K[k],H[h],Z[z]),1.0) + β * EV(x,E[e],Z[z],K[k]))
        -         else
   313145             return -(u(c(A[a],E[e],1.0,x,K[k],H[h],Z[z]),0.0) + β * EV(x,E[e],Z[z],K[k]))
        -         end
        -     end
        - 
        -     #predefining variables and loop stuff
        1     policy = ones(nA,nE,nK,nH,nZ,2) #last dimension indicates if it is the policy for n or a
        -     distance = 1
        1     Vgrid = zeros(nA,nE,nK,nH,nZ)
        1     Vgridf = zeros(nA,nE,nK,nH,nZ)
        6     itpV = LinearInterpolation((A,E,K,H,Z),Vgrid*(1-damp).+damp*Vgridf, extrapolation_bc=Line())
        -     iteration = 1
        -     multiple5 = 0
        -     inner_optimizer = BFGS()
      104     while distance > tol
      206         Vgridf = copy(Vgrid) #store previous loop values to compare
        - 
        -         Threads.@threads for a = 1:nA #Parallel for!!
    15008             for z=1:nZ,h=1:nH, k=1:nK, e = 1:nE
     8088                 Vsolver(x::Array{Float64,1}) = Vf(x::Array{Float64,1};β = β, a = a,e=e,z=z,h=h,k=k,A=A,E=E,K=K,H=H,Z=Z)
   930387                 Vsolver(x::Float64) = Vf(x::Float64;β = β, a = a,e=e,z=z,h=h,k=k,A=A,E=E,K=K,H=H,Z=Z)
        -                 #solver stuff:
    16454                 if η != 1 && E[e]>0
        0                     initial = [1., 0.8]
        0                     lower = [A[2], 0.0]
        0                     upper = [A[end-1], 1.0]
        -                 else
        -                     initial = 1.
     8227                     lower = A[2]
     8227                     upper = A[end-1]
        -                 end
        - 
        - 
    16453                 if η!=1 && E[e]>0 #labor is not exogenous and the agent is not unemployed
        0                    maxV = optimize( Vsolver, lower,upper,initial,Fminbox(inner_optimizer))
        0                     policy[a,e,k,h,z,:] = maxV.minimizer
     8230                 elseif E[e]<=0 #agent is unemployed
     4111                     maxV = optimize( Vsolver,lower,upper)
     8239                     policy[a,e,k,h,z,:] = [maxV.minimizer,0]
        -                 else #labor is exogenous and agent is employed
     4117                     maxV = optimize( Vsolver,lower,upper)
     4120                     policy[a,e,k,h,z,:] = [maxV.minimizer,1]
        -                 end
    19567                 Vgrid[a,e,k,h,z] = maxV.minimum
        -             end
        -         end
        -         #check convergence
        0         if iterate == "Value"
      103             distance = maximum(1/damp*abs.(Vgrid-Vgridf))
        -         else
      206             distance = maximum(abs.(policy-policy_old))
        -         end
        - 
        3         if distance == NaN
        1             error("VFI did not converge")
        -         end
        3         itpV = LinearInterpolation((A,E,K,H,Z),Vgrid*(1-damp).+damp*Vgridf, extrapolation_bc=Line())
  2483674         V(a::Float64,e::Float64,k::Float64,h::Float64,z::Float64) = itpV(a,e,k,h,z) #linear interpolation of the Value function
        1         if (div(iteration,10)>multiple5 && verbose==false)#Only display a message each 10 iterations
        1             println("In iteration $(iteration) distance is $(distance)")
        -             multiple5 = div(iteration,10)
        -         else
        -             println("In iteration $(iteration) distance is $(distance)")
        -         end
        -         iteration +=1
        -     end
        -     #Finally, find labor, capital and consumption policies interpolations:
        -     itpn = LinearInterpolation((A,E,K,H,Z),policy[:,:,:,:,:,2], extrapolation_bc=Line())
   102364     policy_n(a::Float64,e::Float64,k::Float64,h::Float64,z::Float64) = itpn(a,e,k,h,z)
        -     itpa = LinearInterpolation((A,E,K,H,Z),policy[:,:,:,:,:,1], extrapolation_bc=Line())
    99058     policy_a(a::Float64,e::Float64,k::Float64,h::Float64,z::Float64) = itpa(a,e,k,h,z)
        - 
        -     policy_c(a::Float64,e::Float64,k::Float64,h::Float64,z::Float64) = c(a,e,policy_n(a,e,k,h,z),policy_a(a,e,k,h,z),k,h,z)
        -     return  policy_a,policy_n,policy_c,V,policy
        - end
        - 
        - 
        - function KrusselSmith(A::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},
        -     E::Array{Float64,1},pdfE::Array{Float64,2},Z::Array{Float64,1},pdfZ::Array{Float64,2},
        -     K::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},
        -     H::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},
        -     K1::Function,H1::Function,b::Array{Float64,2},d::Array{Float64,2};α::Float64 = α,
        -     β::Float64 = β, η::Float64 = η, μ::Float64=μ, tol::Float64= 1e-6,
        -     iterate::String = "Policy",N::Int64=10000,T::Int64=1500,discard::Int64=500,seed::Int64= 2803, R::Function=R,w::Function=w,
        -     damp::Float64=2/3,damp2::Float64 = 2/3,verbose::Bool = false)
        - 
        1     dist = 1.0
        -     iteration = 0
        -     nZ = length(Z)
        - 
        1     policy_a(a::Float64,e::Float64,k::Float64,h::Float64,z::Float64)  = 1.0
        1     policy_n(a::Float64,e::Float64,k::Float64,h::Float64,z::Float64)  = 1.0
        1     policy_c(a::Float64,e::Float64,k::Float64,h::Float64,z::Float64)  = 1.0
        1     V(a::Float64,e::Float64,k::Float64,h::Float64,z::Float64)  = 1.0
        -     #getting the shocks
        -     Random.seed!(seed)
        1     zsim = simMC(Z,pdfZ,T,Z[1])
        -     esim=ones(N,T)
        -     Threads.@threads for n=1:N
      100         esim[n,:] =  simMC(E,pdfE,T,E[Int64(length(E)/2)])
        -     end
        - 
        1     zsimd = zsim[discard+1:end] #Discarded simulated values for z
        - 
        -     #predefining variables
        3     asim = ones(N,T)
        1     Ksim =ones(T)
      751     Hsim =ones(T)
      750     Ksim[1] = mean(asim[:,1])
        -     csim = ones(N,T)
     1500     nsim = ones(N,T)
        -     policygrid =  ones(nA,nE,nK,nH,nZ,2)
        -     #First guess for V
        - 
      750     for i=1#while dist > tol
        - 
     1503         println("Solving the agent problem")
        3        policy_a,policy_n,policy_c,V,policygrid =  VFI_KS(A,E,pdfE,Z,pdfZ,K,H ,K1,H1,b,d,V;
        -         α = α,β = β, η = η, μ =μ,tol = tol, iterate = iterate,damp = damp, verbose=verbose)
      751         println("Agent Problem solved!")
        - 
        - 
      762         for t=1:T
      764             Ksim[t] = mean(asim[:,t])
        -             Threads.@threads for n=1:N
    62128                 if t<=T-1
    62331                     asim[n,t+1] = policy_a(asim[n,t],esim[n,t],Ksim[t],Hsim[t],zsim[t])
        -                 end
    67611                     nsim[n,t] = policy_n(asim[n,t],esim[n,t],Ksim[t],Hsim[t],zsim[t])
        -                     #csim[n,t] = policy_c(asim[n,t],esim[n,t],Ksim[t],Hsim[t],zsim[t])
        -             end
        1             Hsim[t] = mean(nsim[:,t])
        -         end
        - 
        1         bold = copy(b)
        -         dold = copy(d)
        -         Xb = hcat(ones(T-discard-1),log.(Ksim[discard+1:end-1]))
        -         Xd = hcat(ones(T-discard-1),log.(Hsim[discard+1:end-1]))
        - 
        -         for i=1:nZ
        -             b[i,:] = Xb[zsimd[1:end-1].==Z[i],:]'*Xb[zsimd[1:end-1].==Z[i],:] \
        -             Xb[zsimd[1:end-1].==Z[i],:]'*log.(Ksim[discard+2:end][zsimd[1:end-1].==Z[i]])
        - 
        -             d[i,:] = Xd[zsimd[1:end-1].==Z[i],:]'*Xd[zsimd[1:end-1].==Z[i],:] \
        -             Xd[zsimd[1:end-1].==Z[i],:]'*log.(Hsim[discard+2:end][zsimd[1:end-1].==Z[i]])
        -         end
        - 
        -         dist =1/damp2 * maximum(vcat(abs.(b.-bold),abs.(d.-dold)))
        -         b = (1-damp2)*bold .+ damp2*b
        -         d = (1-damp2)*dold .+ damp2*d
        -         iteration +=1
        -         println("In iteration $(iteration), law distance is $(dist)")
        -     end
        -     csim = csim[:,discard+1:end]
        -     Hsim = Hsim[discard+1:end]
        -     Ksim = Ksim[discard+1:end]
        -     nsim = asim[:,discard+1:end]
        -     asim = asim[:,discard+1:end]
        -     println("Krussell Smith done!")
        -     return policy_a, policy_n, policy_c, V, b, d, csim, nsim, asim, Ksim, Hsim,policygrid
        - end
        - 
